- 의존성 주입
의존성을 연결하는 데는 스프링이 제공하는 두 어노테이션인 @Required 어노테이션과 @Autowired 어노테이션을 사용할 수 있다.
@Required 어노테이션을 세터 메소드에, 
@Autowired 어노테이션을 생성자와 메소드, 필드에 적용할 수 있다.

정리하면 스프링에서 의존성을 주입하는 방법에는 세 가지가 있다.

1. 생성자 기반의 주입
2. 세터 기반 / 메소드 기반의 주입
3. 필드 기반의 주입
==============================================

    1. 생성자 기반의 주입 

    이 유형의 주입은 생성자를 통해 수행된다.
    생성자에 Autowired 어노테이션을 적용할 수 있다.

    @Autowired
    public MessageService( MessageRepository repository ) {
        this.repository = repository;
    }

    여기서 @Autowired 어노테이션 또한 생략할 수 있다.
    이 경우에도 MessageRepository 빈을 삽입해야 하므로 MessageService 생성자를 검사하면서 해당 인자의 유형을 찾게 된다.

    2. 세터 기반 / 메소드 기반의 주입

    두번째 방법은 메소드 ( 일반적으로 setter 메소드 ) 를 선언하고 @Autowired 어노테이션 또는 @Required 어노테이션을 
    적용하는 것이다. 예를 들어 MessageService 생성자를 제거하고 setRepository ( MessageRepository ) 메소드를
    추가할 수 있다.

    public class MessageService{
        ...
        @Required
        public void setRepository( MessageRepository repository ) {
            this.repository = repository;
        }
        ...
    }

    3. 필드 기반의 주입

    @Autowired 어노테이션으로 필드에 직접 적용할 수 있다. 이렇게 했을 경우 세터 메소드를 선언할 필요가 없다.
    
    @Autowired
    private MessageRepository repository;

    그 외 어노테이션 : @Required 및 @Autowired 같은 내장된 어노테이션 외에도
    스프링은 JSR-250 에 지정된 @javax.annotation.Resource 어노테이션과 
    JSR-330 의 @javax.inject.Inject 어노테이션을 지원한다.
    ** ( JSR : Java Specification Request ) : JSR 250 은 Java 플랫폼의 공통 어노테이션을 위한 것.
                                              JSR 330 은 자바를 위한 의존성 주입에 관한 것.
    


    의존성 주입 모범 사례
    반드시 필요한 의존성은 항상 생성자를 통해 주입해야 한다. 이를 통해 생성 이후에 인스턴스는 완전히 초기화되고 주입된 의존성은
    읽기 전용(read-only) 이 된다. 어느 누구도 더 이상 의존성을 변경할 수 없다.

    필수가 아닌 선택적인 의존성은 세터/메소드를 통해 주입할 수 있다.
    필드 기반 주입은 사용하지 말아야 한다. 스프링은 자바 리플렉션 ( Reflection )으로 필드를 주입하고,
    필드 주입방식을 사용하는 것은 위험한 것으로 간주된다. 사실 피해야 하는 이유는 다음과 같다.
        - 의존성을 초기화하고 관리하는 방법과 이들의 의존관계와 같은 의존성의 정보를 숨긴다.
        - 필드 주입은 매우 간단하다. 필드를 정의하고 @Autowired 또는 @Resource 어노테이션을 적용만 하면 된다.
        개발자가 이 방법에 너무 중독되어 너무 많은 의존성을 추가하면 단일 책임 원칙 (SRP ) 을 위반할 수 있다.
        이 내용은 6장 '코드 설계-안정성과 확장성을 고려해 설계하기' 에서 논의한다.

====================================================================================

- 스프링MVC

    스프링MVC는 웹 애플리케이션을 구현하는 기술을 제공한다.
    이것은 자바 EE 서블릿 API 를 기반으로 한다.
    자바 EE 웹 애플리케이션이 서블릿과 어떻게 동작하는지 살펴보면 스프링 MVC 의 역할을 더 쉽게 이해하는데 도움이 된다.

- 자바 EE 서블릿

    자바 EE 서블릿 ( JAVA EE Servlet ) 또는 짧게 서블릿은 톰캣같은 애플리케이션 서버인 서블릿 컨테이너 내에서 동작한다.
    HTTP 요청이 서버에 도착하면 일반적으로 인증, 로깅, 감사와 같은 필터링 작업을 수행하는 필터 리스트를 통과한다.
    요청이 모든 필터를 통과하면 애플리케이션 서버는 특정 패턴과 일치하는 URI 를 포함하는 요청을 처리할 수 있게 등록된 서블릿으로
    요청을 넘겨준다. 
    서블릿이 요청에 대한 처리를 마치면 HTTP 응답은 해당 HTTP 요청을 처리한 같은 필터 세트를 통과한 후 
    클라이언트로 다시 전송된다.
    
    자바 EE 에서 모든 HTTP 요청에 대해 HttpServletRequest 인스턴스가 생성된다.

    그리고 모든 HTTP 응답에 대해 HttpServletResponse 인스턴스가 생성된다.

    여러 요청에서 사용자를 식별하기 위해 애플리케이션 서버는 첫번째 요청을 받으면 HttpSession 인스턴스를 생성한다.

    각 HttpSession 인스턴스는 세션 (session) ID 라고 부르는 ID 를 가진다. 그리고 세션ID 는 HTTP 응답 헤더의 클라이언트에
    쿠키로 전송된다.

    그리고 세션ID 는 Http 응답 헤더의 클라이언트에 쿠키로 전송된다.

    클라이언트는 그 쿠키를 저장하고 다음 요청 시 다시 서버로 보낸다.

    이렇게 해서 서버는 쿠키에서 찾은 세션ID 로 httpSession 인스턴스를 조회해 사용자를 인식할 수 있다.

    자바EE 에서 HttpSessionListener 인터페이스를 구현해 HttpSession 의 라이프 사이클 이벤트를 수신하거나
    ServletRequestListener 인터페이스를 구현해 요청에 대한 라이프 사이클이벤트를 수신하는 리스너를 만들 수 있다.

    서블릿을 생성하기 위해 javax.servlet.http.HttpServlet 을 확장하고 
    @WebServlet 어노테이션을 적용하거나 전통방식으로 자바 EE 웹 애플리케이션의 설정 파일인 web.xml 파일에 등록할 수 있다.

    어느 방법이든, 서버가 일치하는 URI 요청을 라우트할 수 있게 이 서블릿을 하나 이상의 URI 패턴에 
    매핑해야 한다.

    또한 서블릿에서 다음 메소드를 재 정의할 수 있다.
    doGet / doPost / doPut / doDelete

====================================================================================

    Dispatcher Servlet

    스프링 MVC 를 사용하면 서블릿을 생성할 필요가 없다. 
    클래스를 생성해 @Controller 어노테이션을 추가하고
    @RequestMapping 어노테이션으로 특정 URI 패턴에 매핑할 수 있다.
    규약에 따르면 클래스 이름은 보통 Controller 로 끝난다.
    
    스프링은 요청을 받기 위해 핵심 서블릿은  DispatcherServlet 를 활용한다.
    이 DispatcherServlet 은 모든 요청을 처리할 수 있게 설정되어야 하며
    @RequestMapping 어노테이션에 지정된 URI 패턴에 따라 스프링은 요청을 처리할 패턴에 맞는 컨트롤러를 찾는다.
    
    클라이언트 HTTP 요청 -> 애플리케이션 서버 내의 필터 리스트들을 통과 -> 
        서블릿에서 @RequestMapping 어노테이션에 지정된 URI 패턴에 따라 Controller 매핑 -> request, response

    





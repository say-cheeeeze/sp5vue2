- 의존성 주입
의존성을 연결하는 데는 스프링이 제공하는 두 어노테이션인 @Required 어노테이션과 @Autowired 어노테이션을 사용할 수 있다.
@Required 어노테이션을 세터 메소드에, 
@Autowired 어노테이션을 생성자와 메소드, 필드에 적용할 수 있다.

정리하면 스프링에서 의존성을 주입하는 방법에는 세 가지가 있다.

1. 생성자 기반의 주입
2. 세터 기반 / 메소드 기반의 주입
3. 필드 기반의 주입
==============================================

    1. 생성자 기반의 주입 

    이 유형의 주입은 생성자를 통해 수행된다.
    생성자에 Autowired 어노테이션을 적용할 수 있다.

    @Autowired
    public MessageService( MessageRepository repository ) {
        this.repository = repository;
    }

    여기서 @Autowired 어노테이션 또한 생략할 수 있다.
    이 경우에도 MessageRepository 빈을 삽입해야 하므로 MessageService 생성자를 검사하면서 해당 인자의 유형을 찾게 된다.

    2. 세터 기반 / 메소드 기반의 주입

    두번째 방법은 메소드 ( 일반적으로 setter 메소드 ) 를 선언하고 @Autowired 어노테이션 또는 @Required 어노테이션을 
    적용하는 것이다. 예를 들어 MessageService 생성자를 제거하고 setRepository ( MessageRepository ) 메소드를
    추가할 수 있다.

    public class MessageService{
        ...
        @Required
        public void setRepository( MessageRepository repository ) {
            this.repository = repository;
        }
        ...
    }

    3. 필드 기반의 주입

    @Autowired 어노테이션으로 필드에 직접 적용할 수 있다. 이렇게 했을 경우 세터 메소드를 선언할 필요가 없다.
    
    @Autowired
    private MessageRepository repository;

    그 외 어노테이션 : @Required 및 @Autowired 같은 내장된 어노테이션 외에도
    스프링은 JSR-250 에 지정된 @javax.annotation.Resource 어노테이션과 
    JSR-330 의 @javax.inject.Inject 어노테이션을 지원한다.
    ** ( JSR : Java Specification Request ) : JSR 250 은 Java 플랫폼의 공통 어노테이션을 위한 것.
                                              JSR 330 은 자바를 위한 의존성 주입에 관한 것.
    


    의존성 주입 모범 사례
    반드시 필요한 의존성은 항상 생성자를 통해 주입해야 한다. 이를 통해 생성 이후에 인스턴스는 완전히 초기화되고 주입된 의존성은
    읽기 전용(read-only) 이 된다. 어느 누구도 더 이상 의존성을 변경할 수 없다.

    필수가 아닌 선택적인 의존성은 세터/메소드를 통해 주입할 수 있다.
    필드 기반 주입은 사용하지 말아야 한다. 스프링은 자바 리플렉션 ( Reflection )으로 필드를 주입하고,
    필드 주입방식을 사용하는 것은 위험한 것으로 간주된다. 사실 피해야 하는 이유는 다음과 같다.
        - 의존성을 초기화하고 관리하는 방법과 이들의 의존관계와 같은 의존성의 정보를 숨긴다.
        - 필드 주입은 매우 간단하다. 필드를 정의하고 @Autowired 또는 @Resource 어노테이션을 적용만 하면 된다.
        개발자가 이 방법에 너무 중독되어 너무 많은 의존성을 추가하면 단일 책임 원칙 (SRP ) 을 위반할 수 있다.
        이 내용은 6장 '코드 설계-안정성과 확장성을 고려해 설계하기' 에서 논의한다.

====================================================================================

- 스프링MVC

    스프링MVC는 웹 애플리케이션을 구현하는 기술을 제공한다.
    이것은 자바 EE 서블릿 API 를 기반으로 한다.
    자바 EE 웹 애플리케이션이 서블릿과 어떻게 동작하는지 살펴보면 스프링 MVC 의 역할을 더 쉽게 이해하는데 도움이 된다.

- 자바 EE 서블릿

    자바 EE 서블릿 ( JAVA EE Servlet ) 또는 짧게 서블릿은 톰캣같은 애플리케이션 서버인 서블릿 컨테이너 내에서 동작한다.
    HTTP 요청이 서버에 도착하면 일반적으로 인증, 로깅, 감사와 같은 필터링 작업을 수행하는 필터 리스트를 통과한다.
    요청이 모든 필터를 통과하면 애플리케이션 서버는 특정 패턴과 일치하는 URI 를 포함하는 요청을 처리할 수 있게 등록된 서블릿으로
    요청을 넘겨준다. 
    서블릿이 요청에 대한 처리를 마치면 HTTP 응답은 해당 HTTP 요청을 처리한 같은 필터 세트를 통과한 후 
    클라이언트로 다시 전송된다.
    
    자바 EE 에서 모든 HTTP 요청에 대해 HttpServletRequest 인스턴스가 생성된다.

    그리고 모든 HTTP 응답에 대해 HttpServletResponse 인스턴스가 생성된다.

    여러 요청에서 사용자를 식별하기 위해 애플리케이션 서버는 첫번째 요청을 받으면 HttpSession 인스턴스를 생성한다.

    각 HttpSession 인스턴스는 세션 (session) ID 라고 부르는 ID 를 가진다. 그리고 세션ID 는 HTTP 응답 헤더의 클라이언트에
    쿠키로 전송된다.

    그리고 세션ID 는 Http 응답 헤더의 클라이언트에 쿠키로 전송된다.

    클라이언트는 그 쿠키를 저장하고 다음 요청 시 다시 서버로 보낸다.

    이렇게 해서 서버는 쿠키에서 찾은 세션ID 로 httpSession 인스턴스를 조회해 사용자를 인식할 수 있다.

    자바EE 에서 HttpSessionListener 인터페이스를 구현해 HttpSession 의 라이프 사이클 이벤트를 수신하거나
    ServletRequestListener 인터페이스를 구현해 요청에 대한 라이프 사이클이벤트를 수신하는 리스너를 만들 수 있다.

    서블릿을 생성하기 위해 javax.servlet.http.HttpServlet 을 확장하고 
    @WebServlet 어노테이션을 적용하거나 전통방식으로 자바 EE 웹 애플리케이션의 설정 파일인 web.xml 파일에 등록할 수 있다.

    어느 방법이든, 서버가 일치하는 URI 요청을 라우트할 수 있게 이 서블릿을 하나 이상의 URI 패턴에 
    매핑해야 한다.

    또한 서블릿에서 다음 메소드를 재 정의할 수 있다.
    doGet / doPost / doPut / doDelete

====================================================================================

    Dispatcher Servlet

    스프링 MVC 를 사용하면 서블릿을 생성할 필요가 없다. 
    클래스를 생성해 @Controller 어노테이션을 추가하고
    @RequestMapping 어노테이션으로 특정 URI 패턴에 매핑할 수 있다.
    규약에 따르면 클래스 이름은 보통 Controller 로 끝난다.
    
    스프링은 요청을 받기 위해 핵심 서블릿은  DispatcherServlet 를 활용한다.
    이 DispatcherServlet 은 모든 요청을 처리할 수 있게 설정되어야 하며
    @RequestMapping 어노테이션에 지정된 URI 패턴에 따라 스프링은 요청을 처리할 패턴에 맞는 컨트롤러를 찾는다.
    
    클라이언트 HTTP 요청 -> 애플리케이션 서버 내의 필터 리스트들을 통과 -> 
        서블릿에서 @RequestMapping 어노테이션에 지정된 URI 패턴에 따라 Controller 매핑 -> request, response

    

===========================================================

    - 어노테이션 기반의 설정 

        스프링은 의존성을 보다 쉽게 관리할 수 있는 어노테이션 기반의 설정을 제공한다.
        이를 위해 스프링은 크게 두 가지 유형의 어노테이션을 제공한다.

        첫번째는 Bean 을 선언하는 어노테이션이고
        두번째는 의존성을 연결하는 어노테이션이다. 

    - 빈 선언

        우선 빈을 선언하기 위해 스프링 어노테이션을 사용하는 방법을 살펴보면
        @Component, @Service, @Controller, @Repository 를 포함한 스테레오 타입 어노테이션 세트가 제공되는 것을 알 수 있다.

    - 의존성 주입

        스프링에서 제공하는 두 어노테이션인 @Required 와 @Autowired 을 통해 의존성을 연결할 수 있다.
        @Required : 세터 메소드
        @Autowired : 생성자와 메소드, 필드

        정리하자면 스프링에서 의존성 주입하는 방법에는 다음 세 가지가 있다.
        1) 생성자 기반 주입
        2) 세터기반/메소드 기반 주입
        3) 필드 기반 주입 


===========================================================

	스프링 AOP ( Aspect Oriented Programming ) : 관점 지향 프로그래밍

===========================================================

	- 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화한다.
	어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 말한다.

	예를 들어 보안 검사를 실행하는 것이 모든 코드에서 먼저 작동해야 한다고 했을 때.
	메소드 단계에서 보안 검사를 수행하기를 원할 수 있다.

	- 관심사
		AOP 에서 보안 검사는 보안에 관련된 관심사(Concerns) 또는 애플리케이션이 충족해야 하는 목표로 생각할 수 있다.
		일반적으로 관심사는 여러 클래스에 걸쳐 있다.

	- 애스펙트 ( Aspect )
		이러한 관심사들을 모듈화한 것이다. 여러 클래스에 걸쳐 코드를 분산하는 대신 관심사를 다루는 로직을 하나의 애스펙트에 넣는다.
		스프링AOP 에서는 일반 클래스에 애스펙트를 구현할 수 있고 AspectJ 의 어노테이션인 @Aspect 어노테이션을 적용할 수 있다.
		@Around 어노테이션을 통해 메소드가 실행될 시점을 지정할 수 있다.

	- 조인 포인트 ( Join Points )
		특정 프로그램이 실행되는 시점이다.
		스프링 AOP 에서 조인포인트는 항상 메소드 호출을 나타낸다.

	- 어드바이스 ( Advice )
		AOP 에서 어드바이스는 특정 관심사를 처리하는 행동이다. 다양한 유형의 어드바이스가 있다.

		Before Advice ( 이전 ) :    조인포인트 이전에 실행되는 어드바이스로, 예외를 던지지 않는 한 조인 포인트에 도달하는 코드 실행을 막을 수 없다.
								   @Before 어노테이션으로 before advice 를 지정할 수 있다.
	    After returning advice ( 정상적 반환 이후 ) :  예외를 던지지않고 조인 포인트가 정상적으로 완료된 후 실행되는 어드바이스,
	                                               @AfterReturning 어노테이션으로 after returning advice 를 지정할 수 있다.
        After throwing advice ( 예외 발생 이후 ) : 예외를 던져 메소드가 종료될 때 실행되는 어드바이스.
                                               @AfterThrowing 어노테이션으로 after throwing advice 를 지정할 수 있다.
        After advice ( 이후 ) :   조인 포인트 실행과 관계없이 실행되는 어드바이스, try-catch 의 final 블록과 같은 개념이다.
                                @After 어노테이션으로 after advice 를 지정할 수 있다.
		Around advice ( 메소드 실행 전 후 ) :   조인 포인트를 둘러싼 어드바이스.  이 유형의 어드바이스는 코드 실행을 완전히 제어하므로
											가장 강력하다. @Around 어노테이션으로 around advice 를 지정할 수 있다.

	- 포인트컷 ( PointCuts )
		일치하는 여러 조인 포인트를 결합한 것이다.
		다음과 같이 어라운드 어드바이스가 실행되어야 하는 시점을 지정하는 표현식이다.
		포인트 컷 시그니처를 선언한다고도 한다.
		@PointCut("execution(* app.messages..*.*(..))")




2장

Vue.js2 - 기대한 방식으로 동작한다.

메시지 앱 ( Message App ) 이라는 간단한 애플리케이션을 만들어 option 객체가 어떻게 활용되는지 살펴본다.
이 SPA 는 다음과 같은 기능을 가진다.
메시지 추가하기.
메시지 리스트보기.
메시지 삭제하기.
특정 조건에서 추가 기능을 자동으로 비활성화하기

- 컴포넌트
Vue.js 는 프로퍼티 이름을 파스칼 표기법(Pascal Case) 에서 케밥 표기법(kebab-case)으로 변환하고,
컴포넌트를 등록할 때 그 이름을 컴포넌트 ID 로 활용한다.

- 컴포넌트의 이름을 결정할 때에는, 해당 코드에서
변수명과 파일명 같은 것이 작업 중인 도메인의 성격을 잘 반영하는지 고민해야 하며,
그 다음 명명 규약 또는 스타일 가이드를 따르느지 고민해야 한다.
그런 다음 더 짧은 이름을 선택한다.
Vue.js 에는 공식 스타일 가이드가 있는데, 밀접하게 연결되어 있는 컴포넌트들의 이름에 대한 한가지 지침이 있다.
=> '부모 컴포넌트와 밀접하게 연결된 자식 컴포넌트는 부모 컴포넌트의 이름을 접두사로 포함해야 한다.'
ex) MessageList     부모 컴포넌트
	MessageListItem 자식 컴포넌트


- 지시자 ( Directives )
Vue 애플리케이션에서 중요한 역할을 한다.
지시자는 표현식의 값이 변경될 때 이에 반응해 DOM 에 변경사항을 적용한다.
예를 들어 v-for 지시자는 원본 데이터를 기반으로 요소 또는 데이터 블록을 여러 번 렌더링하고,
v-on 지시자는 리스너를 DOM 요소에 부착한다.

기본 내장 지시자를 활용하지 않고 사용자 정의 지시자를 만들 수도 있다.
원래 v-on 이 있는데 v-focus 같은거 만들 수 있다.
그러려면 지시자 정의 객체를 생성하고 이를 Vue.directive() 를 이용해 전역으로 등록하거나
컴포넌트의 directives 프로퍼티를 이용해 해당 컴포넌트에 로컬로 등록하면 된다.

Vue.js 가 지시자 외부에서 일어나는 일들을 다음과 같은 훅 함수를 지시자 정의 객체 내에 추가할 수 있고,
이 훅 함수를 이용해 그에 따른 다양한 로직을 적용할 수 있다.
1) bind : 지시자가 처음 요소에 바인딩 됐을 때 한 번만 호출된다. 여기서 일회성 설정을 수행할 수 있다.
2) inserted : 바인딩 된 요소가 부모 노드에 삽입됐을 때 호출된다. 그러나 이 시점에 부모 노드는 DOM 에 삽입되지 않았을 수도 있음.
3) update : 포함하는 컴포넌트의 VNode 가 업데이트 됐을 때 호출됨. 하지만 자식 컴포넌트의 VNode 가 업데이트 되지 않았을 수도 있음.
4) componentUpdated : 컴포넌트의 VNode 와 자식 컴포넌트의 VNode 가 업데이트된 후에 호출된다.
5) unbind : 요소에서 지시자의 바인딩이 해제될 때 한 번만 호출된다.


directive / focus.directive.js 참고

- 모듈 ( module )
ES6 에서 자바스크립트는 언어 차원에서 모듈을 지원한다.
모듈을 구성하고 정적 모듈 구조를 만드는데 export 와 import 를 사용한다.
컴파일 시점에서 가져오기와 내보내기를 결정할 수 있다.
ES6 모듈의 또 다른 중요한 특징은 가져오기와 내보내기에 대한 선언이 최상위에 위치해야한다.

모듈 내부에서 아무것도 내보내지 않을 것을 선택할 수 있다.
또는 원시 값과 함수, 클래스, 객체를 내보낼 수 있다.
내보내기에는 명명된 내보내기( named export ) 와 기본 내보내기 ( default export ) 의
두 가지 유형이 있다. 동일 모듈에 여러개의 명명된 내보내기가 있을 수 있지만,
하나의 모듈에는 하나의 기본 내보내기만 존재할 수 있다.

- Vue.js 가 index.html 의 submit 버튼을 비활성화하는 동작 원리 ( newMessage의 길이가 50을 초과하는 경우 )
우선 Vue.js 가 DOM 을 렌더링할떄 DOM 의 어느 부분을 업데이트해야하는지 파악한다.
애플리케이션의 초기화 단계에서는 부착 지점이 비어 있으므로 초기 렌더링에 필요한 요소만 생성한다.
예제 템플릿에서는 v-model 지시자를 이용해 textarea 에 데이터 바인딩을 추가했으며, 이 지시자는 양방향 데이터 바인딩을 지원한다.
양방향 데이터 바인딩 지원을 위해 Vue.js 는 textarea 의 input 이벤트를 모니터링하는 리스너를 추가해
textarea에 입력하면 브라우저가 input 이벤트를 발생시키고 리스너가 textarea 의 최신 값을 전달받게 한다.

이 리스너는 최신 값을 vm.newMessage 의 세터 함수에 전달한다. 함수 내부에서는 두개의 와처가 통지를 받는다.
첫번째는 렌더 와처다.
내부적으로는 Vue.js 는 렌더 와처를 vm._watcher에 넣는다.
render 함수를 트리거하는 대신 렌더 와처는 자신을 와처 큐에 넣는다.
Vue.js 스케줄러는 다음 DOM 업데이트 주기에 이 큐를 플러시(flush) 하도록 예약한다.
두번쨰 와처인 addDisabled 와처도 통지를 받는다.
그것은 큐에 들어가는 대신 dirty 플래그를 true 로 변경하고 다음 평가를 기다린다.
스케줄러가 와처큐를 플러시할 때 렌더 와처가 호출된다. 이 때 render 함수를 트리거하고,
이 render함수는 addDisabled 의 평가를 트리거하는 addDisabled 의 게터함수를 호출한다.

vm.newMesssage 의 길이가 50 을 초과하기 전까지는 평가 결과는 항상 false 이다.
Vue.js 는 DOM 에서 어떤 것도 업데이트할 필요가 없기 때문에 DOM 을 조작하지 않는다.
51번째 문자가 입력되면 평가 결과는 true 가 되어 Vue.js 는 이 변화를 감지하고 Submit 버튼의 disabled 프로퍼티를 true 로
업데이트한다.
각 computed 프로퍼티에 대해 Vue.js 는 별도의 와처를 생성한다.
그리고 Vue.js 가 Vue 인스턴스를 파괴할 때 인스턴스의 모든 computed 와처 뿐만 아니라 render 와처도 파괴한다.

- Vue.js 가 index.html 의 MessageList 컴포넌트의 props 를 어떻게 처리하는지?
사실 Vue 인스턴스를 초기화하는 동안 Vue.js 는 data 객체와 computed 프로퍼티 이전에 props 를 먼저 초기화한다.
내부적으로 Vue.js 는 props 에 지정된 데이터를 보관하기 위해 _props 객체를 생성하고
이것을 vm.$children[0]._props 에 넣는다. 여기서 vm 은 Vue 루트 인스턴스이고 $children 은 루트 인스턴스의
자식 컴포넌트를 포함하는 내부 프로퍼티이다.
예제의 경우 하나의 자식 컴포넌트가 존재하고 MessageList 컴포넌트가 이에 해당된다.
그리고 Vue.js 가 MessageList 컴포넌트인스턴스를 생성할 때 Vue.js 는 이 컴포넌트가 message 배열이
items 로 전달되어야 하는 것을 알고 있고, items 를 vm.children[0]._props.items 에 저장한다.
그리고 vm.$children[0].items 에 접근하기 위해 proxy 를 생성한다.
우리가 지금 말하는 vm 은 루트 Vue 인스턴스를 참조한다는 것을 명심하자.
MessageList 컴포넌트 내부에서 템플릿의 items 와 메소드의 this.items 로 items 에 접근한다.
message는 배열이기 때문에 vm$children[0]._props.items 의 값은 실제로 messages 배열의 데이터가 저장된 위치를 참조한다.
크롬 콘솔에 다음 표현식을 입력하면 결과가 true 로 표시되는 것을 확인할 수 있다.
console.log( vm.$children[0]._props["items"] === vm._data.messages ); // true

props 객체는 컴포넌트에 의해 변경되지 않아야 하기 때문에 Vue.js 는 vm._props에 대한
Observer 객체를 생성하지 않는다. 그리고 props 에 정의된 프로퍼티는 읽기 전용으로 간주한다.
즉 MessageList 컴포넌트 내에서 props 의 데이터를 수정하려고 시도해서는 안된다.
실제로 시도한다면 Vue.js 는 앱이 운영모드로 실행 중이 아닌 경우 콘솔에 경고를 던지게 된다.